				DM Btree Overview
				=================

Device mapper uses muti level B+ trees with 64bit keys.

Node Structure
===============

A node can be either internal node or leaf node. A node has a node header
in the beginning followed by keys and values.

struct btree_node {
        struct node_header header;
        __le64 keys[0];
} __packed;


 node-header | keys | values

There is one value associated with each key. Keys with-in node are sorted
and are searched using binary search algorithm.

Tree Structure
==============
There are two kind of nodes. Internal nodes and leaf nodes. Internal node
contain key/value pairs where values are pointing to another internal
node or a leaf node. Leaf nodes have key/value pairs too and store the
final values which caller is looking for.

In the diagram below values have been hidden and only keys are being shown.

		    (Intermediate Node)
                  +------------+
                  | 20|  45| 62+------------------------+
                  ++--------------+                     |
                   |              |                     |
         +---------+----+      +--v-----+-----+     +-----------+
         | 22| 27|      |      | 45| 48 |     |     | 67| 73 |  |
         +--------------+      +--------+-----+     +-----------+
	   (Leaf Node)

Intermediate node has keys (ex 20, 45, 62) and associated values point to
another intermediate or leaf nodes. Convention is that intermediate node
key (key1) points to a node which contains keys greater then key1.

For example, First leaf node can contain keys between 20 and 44. Second
leaf node can contain values between 45 and 61 and third leaf node can
container values greater than or equal to 62 in above picture.

Splitting and Merging
=====================
Looks like constraint on a node are that it can can minimum of n and maximum
of 3n entries.

A node can contain maximum of 3n entries for a given n. This is calculated
using calc_max_entries(). During key insert operation, if we encounter a
node which is full (has max entries), it is split so that if insert operation
adds a key in upper layers, it can be accomodated.

During key deletion node merging or redistribution of keys can take place. When
key balancing is happening between three nodes (__rebalance3()) looks like in
total there need to be 4n + 1 keys otherwise center node is deleted. Not sure
why it is that way. I was thinking that we would target n + 1 keys in each
node so threshold would have been 3n + 3 instead. (or n+1 key in node of
traversal and n keys on 2 other nodes. So threshold should have been 3n + 1).

When 2 nodes are involved in rebalancing (__rebalance2()), then merge threshold
is 2n+1. If total number of keys are less then that, then two nodes are merged
otherwise keys are redistributed such that half the keys in left node and rest
are in right node.

Locking
=======
There are two types of locking. Read only locking and the one which uses
shadowing. Separate type of spine data structures are used for both the
locks.

ro_spine
--------
First type of spine is called ro_spine.

struct ro_spine {
        struct dm_btree_info *info;

        int count;
        struct dm_block *nodes[2];
};

It basically can acquire read locks on maximum two blocks. Looks like idea
is to lock the block we are about to read and also lock the parent if there
is one.

shadow_spine
------------
This is shadow spine and can be used for creating a shadow block and taking
a write lock on that block. This will primarily be used whenever we are
modifying a btree and a shadow block needs to be created.

struct shadow_spine {
        struct dm_btree_info *info;

        int count;
        struct dm_block *nodes[2];

        dm_block_t root;
};

Like ro_spine, it also keeps track of two blocks. Shadowed block is stored
in s->nodes[]. Parent block is locked first and then child block is locked.

->root keeps track of root of the shadowed tree during insert operation. Once
the insertion is complete, caller is returned this new shadowed root.

Common Operations
=================

dm_btree_empty()
----------------
Initialize empty tree. This just allocates a new block and initiliazes it to
zero. Also initializes the node header in the block and returns the block
number.

dm_btree_lookup()
-----------------
Given single/two keys it looks up the multilevel B+ tree and returns the
value. Values are copied in caller specified location in little endian
format.

First a ro_spine is initialized and then btree_lookup_raw() is called for
top level tree. A key search function lower_bound() is passed as parameter.
btree_lookup_raw() takes the read lock on root node and searches for
key using lower_bound(). lower_bound() returns the index where key might
be present. It performs the binary search and either returns the index of
exactly matching key or of the nearest lower key.

If the node we are searching in is leaf node, then value associated with
key index is retrieve and copied in user passed pointer. Actual key looked
up also is returned. That way caller can compare the key and figure out if
exact key was found or not.

        *result_key = le64_to_cpu(ro_node(s)->keys[i]);
        memcpy(v, value_ptr(ro_node(s), i), value_size);

If node was internal node, then for loop continues and this time searching
in children node where key can be and taking a read lock and process repeats.

Upon return from btree_lookup_raw(), dm_btree_lookup() checkes if key exactly
matched or not. If not, -ENODATA is returned otherwise search continues
in the next level of tree and same process repeats one more time.

When all the levels of tree have been traversed and keys match exactly, then
return code 0 is returned and value associated with key has been copied in
caller provided pointer.

dm_btree_insert()
-----------------
Insert or overwrite a value. When a new value is being inserted in a tree,
each node along the path of insertion is shadowed. Also while traversing
down, any node which is full is split. This possibly makes sure that when
we insert a key in leaf, it will at most split leaf node and there will
be space in parent node to take care of split at leaf node.

First it calls btree_insert_raw() for top level tree. This will ensure that
all the nodes in the path are shadowed and if any node was full it will be
split.

If top level key is not already present, that means we need to allocate
another block/tree for lower level and insert it in top level tree leaf
node.

Finally, lower level of tree is checked and we call btree_insert_raw()
again to shadow and lock the modification path and split any full nodes.
If key is not present, it is inserted otherwise value associated with
existing key is overwritten.

If there is dec() operation available on value type and new value is not
same as old value then ->dec() is called on old value before being overwritten.

In the end, root of shadowed tree is returned to the caller.

dm_btree_remove()
-----------------
Removes a key from the btree. It seems to be removing key/value only from
lower level tree.

As we traverse down the tree, we need to make sure that nodes in the key path
have atleast b+1 entries. (Where b = minimum number of entries for a node).
That way during actual key deletion even if one key is deleted from node,
node will still be valid.

To achieve this, as we decend down the tree, we look at all the child nodes
and do rebalancing. We can either delete some node or redistribute entries
among nodes.

dm_btree_remove() first goes through top level tree and calls remove_raw().
remove_raw() will make sure that blocks in the deletion path are shadowed
at the same time it will also do necessary magic of rebalancing or
redistributing keys in nodes so that a deletion of key at leaf node does
not trigger deletion of more nodes.

Once remove_raw() is done with top level tree, we extract the block of lower
level tree and restart the for loop. And now we call remove_raw() on bottom
level tree. Again, shadowing, rebalancing, redistribution happens on lower
level tree and index of key/value to be deleted from bottom tree is returned.

If index is valid, that means key is present in the tree. We call delete_at()
to delete the key. Before that we also call ->dec() method on value, if
there is one.

In the end new shadowed root is returned and we exit the spine, unlocking
any locks on the blocks.

dm_btree_del()
----------------
Delete a btree. A recursive post order deletion algorithm is used. For
example.

                                A                                  
                            +--------+                             
                            | 2 |  11|                             
                            +--------+                             
                            |       |      C                       
                B+----------v-+    +v-------+                      
        +--------+ 2 | 4 |  8 |    |  13| 17+--------------+       
        |        +---------------+ +--------+              |       
        |             |          |    |                    |       
        |             |          |    |                    |       
        |             |          |    |                    |       
    +--------+   +----v---+  +---v--+ |   +------+    +----v---+   
    | 2 |  3 |   |4 | 5| 6|  | 8|10 | +--^+13|14 |    |17 |20  |   
    +--------+   +--------+  +------+     +------+    +--------+   
        D             E          F            G            H       

In above example, deletion order of nodes will be D, E, F, B, G, H, C, A

dm-btree are multi level. So deletion is little more complicated. First
outer most level is deleted and then internal levels are deleted.

A stack is maintained to keep track of nodes to be deleted. First root
of the tree is pushed on to the stack (A). Then current child (starting with
first) is pushed on stack (B). Then current child (D) of current top most
frame (B) is pushed. Now B is top most frame and we notice this is leaf
node and it is not internal level, So info->value_type.dec() is called
on all the elements of node D. Finally pop_frame() is called to pop D
and release it.

Now B is top most frame and current child is E.  (D has already been taken
care of). E is pushed onto stack and in next loop, all elements of E are
free and E itself is freed. Same happens to F. In next round, there are more
children of node B and it is freed.

    if (f->current_child >= f->nr_children) {
           pop_frame(s);
           continue;
   }

And this continues till all the nodes have been freed.

One interesting thing to note is that when we are pushing nodes on to the
frame, we also start IO to prefetch the children blocks (prefetch_children).
We know very soon these will be accessed.

While we are pushing a node onto stack (push_frame) and if the node is
shared (reference count is > 1), that means node can't be freed now. Also
node is shared that means none of the children have to be freed.
So push_frame() just decrements the reference count on the node and returns.

A node is freed by calling pop_frame(). Which in turn drops the reference
count on the node and calls dm_tm_unlock() to free buffer.

Common Internal Operations
==========================

lowerbound()
------------

insert_at()
-----------
It inserts a key and value pair in a node at given index. Also checks that
there is enough space in the node to accomodate new key/value pair.

btree_insert_raw()
------------------
It takes a tree, spine, value type and key to be inserted and returns the
index of where to insert. The node to be inserted is added in shadow spine.

First shadow_step() shadows the root block and takes the write lock. If node
is already full then it is split. There are two methods of splitting, namely
btree_split_beneath() and btree_split_sibling().

btree_split_beneath() works on top most node and it splits it in two and
creates a parent node for two new children. Following is taken from code.

 Before:
        +----------+
        | A ++++++ |
        +----------+


 After:
      +------------+
      | A (shadow) |
      +------------+
          |   |
   +------+   +----+
   |               |
   v               v
 +-------+     +-------+
 | B +++ |     | C +++ |
 +-------+     +-------+

btree_split_sibling() on the other hand works on intermediate nodes and takes
a node and carves out another sibling out of it.

Before:
       +--------+
       | Parent |
       +--------+
          |
          v
     +----------+
     | A ++++++ |
     +----------+


After:
             +--------+
             | Parent |
             +--------+
               |     |
               v     +------+
         +---------+        |
         | A* +++  |        v
         +---------+   +-------+
                       | B +++ |
                       +-------+

Where A* is a shadow of A.

btree_split_beneath()
---------------------
It takes a node, creates a shadow of this node. Then it allocates two new
blocks (new_block()) for left and right children. Now half of parent's entries
(keys and values) are copied to left children and rest are copied to right
children. Parent and child headers are updated accordingly.

At the end, shadow spine is updated to take the right locks. First it now
takes the lock on new shadowed parent and then based on key it decides which
child falls in traversal path (left or right) and then takes the lock on
that child.

btree_split_sibling()
---------------------
This assumes that there is already a parent for node being split and there
is enough space in parent to add another key/value pair. First we shadow
the node being split and then allocate another node which will act as right
child. Half of the key/values are in left node and rest half are copied to
right node.

Now parent node is updated to point to new shadowed left children (it was
pointing to unshadowed child). And a new key/value is inserted in parent to
point to new right children.

Finally spine is updated to take lock on left or right child depending on
the key being searched. One notable difference here is that we don't check
the parent block in spine (s->nodes[0]). I think that comes from the fact
that we already must have shadowed the parent and already must have updated
the spine and this check will be redundant.

We always shadow a block as we traverse down in insertion path and update the
spine accordingly. So if we are splitting a child node, that means parent
has already been shadowed and spine is already pointing to right parent and
has write lock on it.

remove_raw()
------------
This function shadows the block passed in and takes read-write lock. If this
is leaf node, key/value pair is removed otherwise it tries to rebalance
the children (rebalance_children()). Once rebalancing is done, we check if
current shadowed block is leaf node and if yes, delete the key/value and
return. Otherwise, we are still in internal node and we search for the key
and retrieve the value of the next level block and repeat the loop.

Once we shadow a node and if there is parent of the node, then we need to
patch the parent to point to shadowed child and not the new child. This
is along the lines that every insert/remove operation shadowes all the
nodes in the path of modification.

if (shadow_has_parent(s)) {
	 __le64 location = cpu_to_le64(dm_block_location(shadow_current(s)));
	memcpy(value_ptr(dm_block_data(shadow_parent(s)), i),
                         &location, sizeof(__le64));
}

rebalance_children()
--------------------
If there is only one entry in node, that means there is only one child. That
also means that one node is redundant. Hence all child's data is copied to
parent and child is freed and function returns.

Now we look for index of key with-in node. If we found a valid index for key,
then we figure out how child belonging to that index has how many siblings. If
there are both left and right sibling then rebalance3() is called. If only
ther is only one sibling (either left/right), then rebalance2() is called.

rebalance2() and __rebalance2()
--------------------------------
It first creates copies of both left and right children and modifies
the parent to point to copies. Then __rebalance2() is called. __rebalance2()
either merges two into a single node or redistributes the entries among
the two.

TODO: Figure how the rationale behind threshold calculation. And also figure
      out why redistribution helps. Why not simply return if child in the
      removal path has minimum b+1 entries.

rebalance3() and __rebalance3()
-------------------------------
It gets index of left most child and then it creates copies of left, center
and right child and updates the parent accordingly. Then it calls __rebalance3().

__rebalance3() determines the threshold and if total number of enteries are
less then that threshold, it deletes center node otherwise it redistributes
entries using redistribute3().

TODO: Figure out how threshold is calculated.


